#!/usr/bin/env bash
# scripts/protocol-zero.sh
# Protocol Zero Enforcement: Automated Attribution Scanning
#
# Scans codebase and commit metadata for forbidden AI attribution markers.
# Returns exit code 0 on success, 1 on violation detection.
#
# Usage:
#   ./scripts/protocol-zero.sh              # Scan entire codebase
#   ./scripts/protocol-zero.sh --commit-msg "message"   # Validate commit message
#   ./scripts/protocol-zero.sh --commit-msg-file path   # Validate commit message from file

set -euo pipefail

# Color definitions (ANSI escape codes)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Prohibited patterns (case-insensitive matching)
# These patterns indicate AI attribution that violates Protocol Zero
PROHIBITED_PATTERNS=(
    "generated by claude"
    "generated by ai"
    "generated by copilot"
    "generated by gpt"
    "generated by chatgpt"
    "generated by llm"
    "ai.assisted"
    "ai-assisted"
    "ai assisted"
    "ai generated"
    "ai-generated"
    "created with ai"
    "created by ai"
    "written by ai"
    "written by claude"
    "co-authored-by:.*claude"
    "co-authored-by:.*copilot"
    "co-authored-by:.*ai"
    "co-authored-by:.*anthropic"
    "co-authored-by:.*openai"
    "i hope this helps"
    "as requested"
    "here is the code"
    "as an ai"
    "as a language model"
    "i'm an ai"
    "i am an ai"
    "\\bllm\\b"
)

# Directory names to exclude from scanning (used with grep --exclude-dir)
EXCLUDE_DIRS=(
    "node_modules"
    ".git"
    ".next"
    ".pnpm"
    "dist"
    "build"
    ".turbo"
    ".venv"
    "out"
    "drafts"
    "__pycache__"
)

# Path patterns to exclude (checked via should_exclude_file)
# These are governance/documentation paths that describe the policy
EXCLUDE_PATH_PATTERNS=(
    "docs/"
    ".github/"
    ".claude/"
)

# Files to exclude (governance files that may contain the patterns as documentation)
EXCLUDE_FILES=(
    "CLAUDE.md"
    "CLAUDE-CONTEXT.md"
    "jd-prompt.md"
    "protocol-zero.sh"
    "design_doc.md"
    "claudehome.md"
    "pyproject.toml"
    "README.md"
)

# Binary extensions to skip
BINARY_EXTENSIONS=(
    "png" "jpg" "jpeg" "gif" "ico" "svg" "webp"
    "woff" "woff2" "ttf" "eot" "otf"
    "pdf" "zip" "tar" "gz" "bz2"
    "mp3" "mp4" "wav" "avi" "mov"
    "lock" "lockb"
)

# Track violations
VIOLATIONS_FOUND=0
VIOLATION_DETAILS=()

# Print functions
print_pass() {
    echo -e "${GREEN}${BOLD}[PASS]${NC} ${GREEN}$1${NC}"
}

print_fail() {
    echo -e "${RED}${BOLD}[FAIL]${NC} ${RED}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_info() {
    echo -e "[INFO] $1"
}

print_violation() {
    local file="$1"
    local line_num="$2"
    local content="$3"
    local pattern="$4"
    echo -e "  ${RED}├─${NC} ${BOLD}$file${NC}:${line_num}"
    echo -e "  │  Pattern: ${YELLOW}$pattern${NC}"
    echo -e "  │  Content: ${content:0:80}"
}

# Build grep exclusion arguments
build_exclude_args() {
    local args=""
    for dir in "${EXCLUDE_DIRS[@]}"; do
        args="$args --exclude-dir=$dir"
    done
    for ext in "${BINARY_EXTENSIONS[@]}"; do
        args="$args --exclude=*.$ext"
    done
    for file in "${EXCLUDE_FILES[@]}"; do
        args="$args --exclude=$file"
    done
    echo "$args"
}

# Check if a file should be excluded
should_exclude_file() {
    local filepath="$1"
    local filename
    filename=$(basename "$filepath")

    # Check excluded filenames
    for exclude in "${EXCLUDE_FILES[@]}"; do
        if [[ "$filename" == "$exclude" ]]; then
            return 0
        fi
    done

    # Check excluded path patterns
    for path_pattern in "${EXCLUDE_PATH_PATTERNS[@]}"; do
        if [[ "$filepath" == *"$path_pattern"* ]]; then
            return 0
        fi
    done

    return 1
}

# Scan a single text string for violations
# Returns 0 (success/true) if violations found, 1 (failure/false) if clean
scan_text() {
    local text="$1"
    local source="${2:-stdin}"
    local found=1  # 1 = no violations found (false in bash)

    for pattern in "${PROHIBITED_PATTERNS[@]}"; do
        if echo "$text" | grep -iEq "$pattern"; then
            found=0  # 0 = violation found (true in bash)
            VIOLATIONS_FOUND=1
            local match
            match=$(echo "$text" | grep -iE "$pattern" | head -1)
            VIOLATION_DETAILS+=("Source: $source | Pattern: $pattern | Match: ${match:0:60}")
        fi
    done

    return $found
}

# Scan commit message
scan_commit_message() {
    local message="$1"

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Protocol Zero: Commit Message Validation"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    if scan_text "$message" "commit-message"; then
        print_fail "Protocol Zero Violation Detected in Commit Message!"
        echo ""
        echo -e "${RED}${BOLD}Violations:${NC}"
        for detail in "${VIOLATION_DETAILS[@]}"; do
            echo -e "  ${RED}├─${NC} $detail"
        done
        echo ""
        echo -e "${YELLOW}${BOLD}Action Required:${NC} Remove attribution before proceeding."
        echo ""
        return 1
    else
        print_pass "Protocol Zero: Commit message is compliant."
        return 0
    fi
}

# Scan entire codebase
scan_codebase() {
    local root_dir="${1:-.}"

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Protocol Zero: Codebase Attribution Scan"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    print_info "Scanning directory: $root_dir"
    print_info "Excluded directories: ${EXCLUDE_DIRS[*]}"
    print_info "Excluded files: ${EXCLUDE_FILES[*]}"
    echo ""

    local exclude_args
    exclude_args=$(build_exclude_args)

    local files_scanned=0
    local violations_in_files=()

    for pattern in "${PROHIBITED_PATTERNS[@]}"; do
        # Use grep with exclusions
        local grep_cmd="grep -rilE $exclude_args \"$pattern\" \"$root_dir\" 2>/dev/null || true"
        local matches
        matches=$(eval "$grep_cmd")

        if [[ -n "$matches" ]]; then
            while IFS= read -r filepath; do
                # Double-check exclusion (belt and suspenders)
                if should_exclude_file "$filepath"; then
                    continue
                fi

                # Get line numbers and content
                local line_matches
                line_matches=$(grep -inE "$pattern" "$filepath" 2>/dev/null || true)

                if [[ -n "$line_matches" ]]; then
                    VIOLATIONS_FOUND=1
                    while IFS= read -r line_match; do
                        local line_num
                        line_num=$(echo "$line_match" | cut -d: -f1)
                        local content
                        content=$(echo "$line_match" | cut -d: -f2-)
                        violations_in_files+=("$filepath:$line_num|$pattern|$content")
                    done <<< "$line_matches"
                fi
            done <<< "$matches"
        fi
    done

    # Count total files scanned (approximate)
    files_scanned=$(find "$root_dir" -type f \
        ! -path "*/node_modules/*" \
        ! -path "*/.git/*" \
        ! -path "*/.next/*" \
        ! -path "*/.pnpm/*" \
        ! -path "*/.venv/*" \
        ! -path "*/out/*" \
        ! -name "*.png" ! -name "*.jpg" ! -name "*.ico" \
        ! -name "*.woff*" ! -name "*.ttf" \
        ! -name "*.lock" ! -name "*.lockb" \
        2>/dev/null | wc -l | tr -d ' ')

    print_info "Files scanned: ~$files_scanned"
    echo ""

    if [[ $VIOLATIONS_FOUND -eq 1 ]]; then
        print_fail "Protocol Zero Violation Detected!"
        echo ""
        echo -e "${RED}${BOLD}Violations Found:${NC}"

        # Deduplicate and display violations
        local prev_file=""
        for violation in "${violations_in_files[@]}"; do
            local filepath
            filepath=$(echo "$violation" | cut -d'|' -f1)
            local file_part
            file_part=$(echo "$filepath" | cut -d: -f1)
            local line_num
            line_num=$(echo "$filepath" | cut -d: -f2)
            local pattern
            pattern=$(echo "$violation" | cut -d'|' -f2)
            local content
            content=$(echo "$violation" | cut -d'|' -f3-)

            if [[ "$file_part" != "$prev_file" ]]; then
                echo ""
                prev_file="$file_part"
            fi
            print_violation "$file_part" "$line_num" "$content" "$pattern"
        done

        echo ""
        echo -e "${YELLOW}${BOLD}Action Required:${NC} Remove attribution before proceeding."
        echo ""
        return 1
    else
        print_pass "Protocol Zero: No attribution artifacts detected."
        return 0
    fi
}

# Main entry point
main() {
    local mode="codebase"
    local commit_msg=""
    local commit_msg_file=""
    local scan_dir="."

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --commit-msg)
                mode="commit"
                commit_msg="$2"
                shift 2
                ;;
            --commit-msg-file)
                mode="commit-file"
                commit_msg_file="$2"
                shift 2
                ;;
            --dir)
                scan_dir="$2"
                shift 2
                ;;
            --help|-h)
                echo "Protocol Zero Enforcement Script"
                echo ""
                echo "Usage:"
                echo "  $0                           Scan entire codebase"
                echo "  $0 --dir <path>              Scan specific directory"
                echo "  $0 --commit-msg \"message\"    Validate commit message"
                echo "  $0 --commit-msg-file <path>  Validate commit message from file"
                echo ""
                echo "Exit Codes:"
                echo "  0  No violations detected"
                echo "  1  Violation(s) detected"
                exit 0
                ;;
            *)
                print_warning "Unknown argument: $1"
                shift
                ;;
        esac
    done

    # Execute appropriate scan
    case $mode in
        commit)
            scan_commit_message "$commit_msg"
            ;;
        commit-file)
            if [[ ! -f "$commit_msg_file" ]]; then
                print_fail "Commit message file not found: $commit_msg_file"
                exit 1
            fi
            local msg
            msg=$(cat "$commit_msg_file")
            scan_commit_message "$msg"
            ;;
        codebase)
            scan_codebase "$scan_dir"
            ;;
    esac
}

main "$@"
